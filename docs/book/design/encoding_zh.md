# 编码、开销和验证

以下列表总结了 Walrus 中使用的基本编码和加密技术：

- [纠删码](https://en.wikipedia.org/wiki/Erasure_code)编码算法接受一个 blob，将其分割为 \(k\) 个符号，并将其编码为 \(n>k\) 个符号，使得这些 \(n\) 个符号的子集可以用于重构 blob。

- Walrus 使用高效的纠删码并选择 \(k\)，使得三分之一的符号可以被解码算法用于重构 blob。

- 编码是*系统性的*，意味着一些存储节点持有原始 blob 的一部分，允许快速随机访问读取。

- 所有编码和解码操作都是确定性的，编码器对此没有任何自由裁量权。

- 对于每个 blob，多个符号被组合成一个 **sliver**，然后分配给一个分片。

- 存储节点管理一个或多个分片，每个 blob 的相应 slivers 分布到所有存储分片。

详细的编码设置导致 blob 大小扩展了 \(4.5 \sim 5\) 倍。这与分片数量和存储节点数量无关。

---

每个 blob 还与一些元数据相关联，包括用于验证的 **blob ID**：

- blob ID 被计算为所有分片数据和元数据（字节大小、编码、blob 哈希）集合的认证器。

  Walrus 对每个分片中的 sliver 表示进行哈希，并将结果哈希添加到 Merkle 树中。然后 Merkle 树的根是用于派生在系统中标识 blob 的 blob ID 的 blob 哈希。

- 每个存储节点可以使用 blob ID 来检查某些分片数据是否属于使用与 blob 哈希（Merkle 树）对应的认证结构的 blob。成功的检查意味着数据确实是 blob 写入者的意图。

- 由于 blob 的写入者可能错误地编码了 blob（出于错误或故意），任何从分片 slivers 重构 blob ID 的方必须检查它是否编码为正确的 blob ID。在接受任何声称是特定 blob ID 的 blob 时，同样是必要的。

  此过程涉及使用纠删码重新编码 blob，并再次派生 blob ID 以检查 blob 是否匹配。这防止任何正确的接收者将格式错误的 blob（不正确的纠删编码）读取为有效的 blob。

- 属于 blob ID 的等于重构阈值的一组 slivers，如果不一致或导致重构不同的 ID，则表示编码不正确。这只有在编码 blob 的用户有故障或恶意并且错误编码时才会发生。

  Walrus 可以从每个 sliver 中提取一个符号来形成不一致性证明。存储节点可以删除属于不一致编码 blobs 的 slivers，并根据请求返回不一致性证明或在链上发布的不一致性证书。