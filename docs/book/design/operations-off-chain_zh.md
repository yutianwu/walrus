# 链下操作

虽然 Walrus 操作发生在 Sui 链下，但它们可能与定义资源生命周期的区块链流程交互。

## 写入路径

![Walrus 的写入路径](../assets/WriteFlow.png)

写入的系统概览，如上图所示：

- 用户在链上获取适当大小和持续时间的存储资源，可以通过直接从 Walrus 系统对象购买或在二级市场购买。用户可以分割、合并和转移拥有的存储资源。

- 当用户想要存储 blob 时，他们首先对其进行纠删编码并计算 blob ID。然后他们可以自己执行以下步骤，或使用发布者代表他们执行步骤。

- 用户上链（Sui）并更新存储资源以注册具有所需大小和生命周期的 blob ID。这会发出一个事件，由存储节点接收。用户收到后继续上传。

- 用户将 blob 元数据发送到所有存储节点，并将每个 blob slivers 发送到当前管理相应分片的存储节点。

- 管理分片的存储节点接收 sliver 并根据 blob ID 检查它。它还检查是否有带有 blob ID 的 blob 资源被授权存储 blob。如果正确，存储节点然后签署一个声明，表明它持有 blob ID（和元数据）的 sliver 并将其返回给用户。

- 用户将从存储节点返回的签名组合成可用性证书并将其提交到链上。当证书在链上验证时，为 blob ID 发出可用性事件，所有其他存储节点寻求下载 blob ID 的任何缺失分片。Sui 发出的此事件是 blob ID 的[可用性点（PoA）](./properties_zh.md)。

- 在 PoA 之后，在没有用户参与的情况下，存储节点同步并恢复任何缺失的元数据和 slivers。

用户等待 2/3 的分片签名返回以创建可用性证书。代码的比率低于 1/3，即使只有 1/3 的分片为读取返回 sliver，也允许重构。由于最多 1/3 的存储节点可能失败，这确保了如果读者从所有存储节点请求 slivers，则可以重构。整个过程可以由接收 blob 并推动过程完成的发布者进行调解。

## 刷新可用性

由于刷新存储持续时间不需要内容数据，刷新完全在协议内的链上进行。要请求延长 blob 的可用性，用户提供适当的存储资源。成功后，这会发出存储节点接收的事件，以延长存储每个 sliver 的时间。

## 不一致资源流程

当正确的存储节点尝试在[PoA](./properties_zh.md)之后为 blob 重构 sliver 时，如果 blob 的编码不正确，这可能会失败。在这种情况下，存储节点可以改为提取 blob ID 的不一致性证明。然后它使用证明创建不一致性证书并在链上上传。

流程如下：

- 存储节点无法重构 sliver，而是计算不一致性证明。

- 存储节点将 blob ID 和不一致性证明发送到 Walrus 纪元的所有存储节点。存储节点验证证明并签署它。

- 发现不一致性的存储节点将签名聚合为不一致性证书并将其发送到 Walrus 智能合约，该合约验证它并发出不一致资源事件。

- 收到不一致资源事件后，正确的存储节点删除 blob ID 的 sliver 数据，并在元数据中记录在[可用期](./properties_zh.md)内为 blob ID 返回 `None`。不会为此 blob ID 发出存储证明挑战。

```admonish tip title="读取不一致的 blobs"
不一致的 blob ID 在读取时总是解析为 `None`，因为读取过程重新编码接收到的 blob 以检查 blob ID 是否从一致编码中正确派生。这意味着不一致性证明只向存储节点（否则不运行解码）揭示真实事实，并且在任何情况下都不会改变读取的输出。

但是，利用编码系统的性质的部分读取可能成功返回不一致编码文件的部分读取。因此，如果读取的一致性和可用性很重要，dApps 应该执行完整读取而不是部分读取。
```

## 读取路径

用户可以直接或通过聚合器/缓存读取存储的 blobs。对于直接用户访问、聚合器和缓存未命中情况下的缓存，操作是相同的。实际上，大多数读取通过缓存对热 blobs 进行，不会导致对存储节点的请求。

- 读者从任何存储节点获取 blob ID 的元数据，并使用 blob ID 对其进行身份验证。

- 然后读者向存储节点发送对应于 blob ID 的分片请求，并等待 \(f+1\) 个响应。并行发送足够的请求以确保读取的低延迟。

- 读者使用 blob ID 验证返回的 slivers，重构 blob，并决定内容是有效 blob 还是不一致的。

- 可选地，对于缓存，结果被缓存并可以在不重构的情况下提供服务，直到它从缓存中被驱逐。对缓存的 blob 请求返回 blob 内容，或 blob 不一致编码的证明。

## 存储证明的挑战机制

在一个纪元期间，正确的存储节点挑战所有分片为 PoA 之后的 blob slivers 提供符号：

- 纪元的可用 blobs 列表由过去纪元的 Sui 事件序列确定。不一致的 blobs 不被挑战，可以返回证明此状态的记录。

- 通过向被挑战的分片提供种子来确定挑战序列。然后基于种子**和**每个被挑战的 blob ID 的内容计算序列。这创建了顺序读取依赖性。

- 对挑战的响应及时提供 blob IDs 的分片内容序列。

- 挑战者节点使用阈值确定挑战是否通过，并在链上报告结果。

- 挑战/响应通信经过身份验证。

挑战以概率方式提供存储节点实际可以恢复分片数据的一些保证，避免存储节点在没有任何证据表明他们可能检索分片数据的情况下获得付款。挑战的顺序性质和一些合理的超时也确保过程是及时的。